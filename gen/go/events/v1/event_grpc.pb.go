// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: events/v1/event.proto

package eventspb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EventService_CreateLesson_FullMethodName         = "/events.v1.EventService/CreateLesson"
	EventService_GetLesson_FullMethodName            = "/events.v1.EventService/GetLesson"
	EventService_ListLessons_FullMethodName          = "/events.v1.EventService/ListLessons"
	EventService_UpdateLesson_FullMethodName         = "/events.v1.EventService/UpdateLesson"
	EventService_DeleteLesson_FullMethodName         = "/events.v1.EventService/DeleteLesson"
	EventService_CreateTask_FullMethodName           = "/events.v1.EventService/CreateTask"
	EventService_GetTask_FullMethodName              = "/events.v1.EventService/GetTask"
	EventService_ListTasks_FullMethodName            = "/events.v1.EventService/ListTasks"
	EventService_UpdateTask_FullMethodName           = "/events.v1.EventService/UpdateTask"
	EventService_DeleteTask_FullMethodName           = "/events.v1.EventService/DeleteTask"
	EventService_CreateLessonSchedule_FullMethodName = "/events.v1.EventService/CreateLessonSchedule"
	EventService_GetLessonSchedule_FullMethodName    = "/events.v1.EventService/GetLessonSchedule"
	EventService_ListLessonSchedules_FullMethodName  = "/events.v1.EventService/ListLessonSchedules"
	EventService_UpdateLessonSchedule_FullMethodName = "/events.v1.EventService/UpdateLessonSchedule"
	EventService_DeleteLessonSchedule_FullMethodName = "/events.v1.EventService/DeleteLessonSchedule"
	EventService_CreateTaskSchedule_FullMethodName   = "/events.v1.EventService/CreateTaskSchedule"
	EventService_GetTaskSchedule_FullMethodName      = "/events.v1.EventService/GetTaskSchedule"
	EventService_ListTaskSchedules_FullMethodName    = "/events.v1.EventService/ListTaskSchedules"
	EventService_UpdateTaskSchedule_FullMethodName   = "/events.v1.EventService/UpdateTaskSchedule"
	EventService_DeleteTaskSchedule_FullMethodName   = "/events.v1.EventService/DeleteTaskSchedule"
	EventService_BatchCreateLessons_FullMethodName   = "/events.v1.EventService/BatchCreateLessons"
	EventService_BatchCreateTasks_FullMethodName     = "/events.v1.EventService/BatchCreateTasks"
	EventService_BatchUpdateLessons_FullMethodName   = "/events.v1.EventService/BatchUpdateLessons"
	EventService_BatchUpdateTasks_FullMethodName     = "/events.v1.EventService/BatchUpdateTasks"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventServiceClient interface {
	CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*Lesson, error)
	GetLesson(ctx context.Context, in *GetLessonRequest, opts ...grpc.CallOption) (*Lesson, error)
	ListLessons(ctx context.Context, in *LessonFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Lesson], error)
	UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*Lesson, error)
	DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*Task, error)
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error)
	ListTasks(ctx context.Context, in *TaskFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Task], error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*Task, error)
	DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateLessonSchedule(ctx context.Context, in *CreateLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error)
	GetLessonSchedule(ctx context.Context, in *GetLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error)
	ListLessonSchedules(ctx context.Context, in *LessonScheduleFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LessonSchedule], error)
	UpdateLessonSchedule(ctx context.Context, in *UpdateLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error)
	DeleteLessonSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateTaskSchedule(ctx context.Context, in *CreateTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error)
	GetTaskSchedule(ctx context.Context, in *GetTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error)
	ListTaskSchedules(ctx context.Context, in *TaskScheduleFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskSchedule], error)
	UpdateTaskSchedule(ctx context.Context, in *UpdateTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error)
	DeleteTaskSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Батч-операции
	BatchCreateLessons(ctx context.Context, in *BatchCreateLessonsRequest, opts ...grpc.CallOption) (*BatchLessonsResponse, error)
	BatchCreateTasks(ctx context.Context, in *BatchCreateTasksRequest, opts ...grpc.CallOption) (*BatchTasksResponse, error)
	BatchUpdateLessons(ctx context.Context, in *BatchUpdateLessonsRequest, opts ...grpc.CallOption) (*BatchLessonsResponse, error)
	BatchUpdateTasks(ctx context.Context, in *BatchUpdateTasksRequest, opts ...grpc.CallOption) (*BatchTasksResponse, error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) CreateLesson(ctx context.Context, in *CreateLessonRequest, opts ...grpc.CallOption) (*Lesson, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lesson)
	err := c.cc.Invoke(ctx, EventService_CreateLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetLesson(ctx context.Context, in *GetLessonRequest, opts ...grpc.CallOption) (*Lesson, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lesson)
	err := c.cc.Invoke(ctx, EventService_GetLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListLessons(ctx context.Context, in *LessonFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Lesson], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[0], EventService_ListLessons_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LessonFilter, Lesson]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListLessonsClient = grpc.ServerStreamingClient[Lesson]

func (c *eventServiceClient) UpdateLesson(ctx context.Context, in *UpdateLessonRequest, opts ...grpc.CallOption) (*Lesson, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Lesson)
	err := c.cc.Invoke(ctx, EventService_UpdateLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) DeleteLesson(ctx context.Context, in *DeleteLessonRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventService_DeleteLesson_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, EventService_CreateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, EventService_GetTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListTasks(ctx context.Context, in *TaskFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Task], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[1], EventService_ListTasks_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskFilter, Task]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListTasksClient = grpc.ServerStreamingClient[Task]

func (c *eventServiceClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Task)
	err := c.cc.Invoke(ctx, EventService_UpdateTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) DeleteTask(ctx context.Context, in *DeleteTaskRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventService_DeleteTask_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) CreateLessonSchedule(ctx context.Context, in *CreateLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LessonSchedule)
	err := c.cc.Invoke(ctx, EventService_CreateLessonSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetLessonSchedule(ctx context.Context, in *GetLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LessonSchedule)
	err := c.cc.Invoke(ctx, EventService_GetLessonSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListLessonSchedules(ctx context.Context, in *LessonScheduleFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LessonSchedule], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[2], EventService_ListLessonSchedules_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LessonScheduleFilter, LessonSchedule]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListLessonSchedulesClient = grpc.ServerStreamingClient[LessonSchedule]

func (c *eventServiceClient) UpdateLessonSchedule(ctx context.Context, in *UpdateLessonScheduleRequest, opts ...grpc.CallOption) (*LessonSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LessonSchedule)
	err := c.cc.Invoke(ctx, EventService_UpdateLessonSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) DeleteLessonSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventService_DeleteLessonSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) CreateTaskSchedule(ctx context.Context, in *CreateTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskSchedule)
	err := c.cc.Invoke(ctx, EventService_CreateTaskSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) GetTaskSchedule(ctx context.Context, in *GetTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskSchedule)
	err := c.cc.Invoke(ctx, EventService_GetTaskSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) ListTaskSchedules(ctx context.Context, in *TaskScheduleFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TaskSchedule], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[3], EventService_ListTaskSchedules_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TaskScheduleFilter, TaskSchedule]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListTaskSchedulesClient = grpc.ServerStreamingClient[TaskSchedule]

func (c *eventServiceClient) UpdateTaskSchedule(ctx context.Context, in *UpdateTaskScheduleRequest, opts ...grpc.CallOption) (*TaskSchedule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskSchedule)
	err := c.cc.Invoke(ctx, EventService_UpdateTaskSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) DeleteTaskSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, EventService_DeleteTaskSchedule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) BatchCreateLessons(ctx context.Context, in *BatchCreateLessonsRequest, opts ...grpc.CallOption) (*BatchLessonsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchLessonsResponse)
	err := c.cc.Invoke(ctx, EventService_BatchCreateLessons_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) BatchCreateTasks(ctx context.Context, in *BatchCreateTasksRequest, opts ...grpc.CallOption) (*BatchTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchTasksResponse)
	err := c.cc.Invoke(ctx, EventService_BatchCreateTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) BatchUpdateLessons(ctx context.Context, in *BatchUpdateLessonsRequest, opts ...grpc.CallOption) (*BatchLessonsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchLessonsResponse)
	err := c.cc.Invoke(ctx, EventService_BatchUpdateLessons_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) BatchUpdateTasks(ctx context.Context, in *BatchUpdateTasksRequest, opts ...grpc.CallOption) (*BatchTasksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchTasksResponse)
	err := c.cc.Invoke(ctx, EventService_BatchUpdateTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
type EventServiceServer interface {
	CreateLesson(context.Context, *CreateLessonRequest) (*Lesson, error)
	GetLesson(context.Context, *GetLessonRequest) (*Lesson, error)
	ListLessons(*LessonFilter, grpc.ServerStreamingServer[Lesson]) error
	UpdateLesson(context.Context, *UpdateLessonRequest) (*Lesson, error)
	DeleteLesson(context.Context, *DeleteLessonRequest) (*emptypb.Empty, error)
	CreateTask(context.Context, *CreateTaskRequest) (*Task, error)
	GetTask(context.Context, *GetTaskRequest) (*Task, error)
	ListTasks(*TaskFilter, grpc.ServerStreamingServer[Task]) error
	UpdateTask(context.Context, *UpdateTaskRequest) (*Task, error)
	DeleteTask(context.Context, *DeleteTaskRequest) (*emptypb.Empty, error)
	CreateLessonSchedule(context.Context, *CreateLessonScheduleRequest) (*LessonSchedule, error)
	GetLessonSchedule(context.Context, *GetLessonScheduleRequest) (*LessonSchedule, error)
	ListLessonSchedules(*LessonScheduleFilter, grpc.ServerStreamingServer[LessonSchedule]) error
	UpdateLessonSchedule(context.Context, *UpdateLessonScheduleRequest) (*LessonSchedule, error)
	DeleteLessonSchedule(context.Context, *DeleteScheduleRequest) (*emptypb.Empty, error)
	CreateTaskSchedule(context.Context, *CreateTaskScheduleRequest) (*TaskSchedule, error)
	GetTaskSchedule(context.Context, *GetTaskScheduleRequest) (*TaskSchedule, error)
	ListTaskSchedules(*TaskScheduleFilter, grpc.ServerStreamingServer[TaskSchedule]) error
	UpdateTaskSchedule(context.Context, *UpdateTaskScheduleRequest) (*TaskSchedule, error)
	DeleteTaskSchedule(context.Context, *DeleteScheduleRequest) (*emptypb.Empty, error)
	// Батч-операции
	BatchCreateLessons(context.Context, *BatchCreateLessonsRequest) (*BatchLessonsResponse, error)
	BatchCreateTasks(context.Context, *BatchCreateTasksRequest) (*BatchTasksResponse, error)
	BatchUpdateLessons(context.Context, *BatchUpdateLessonsRequest) (*BatchLessonsResponse, error)
	BatchUpdateTasks(context.Context, *BatchUpdateTasksRequest) (*BatchTasksResponse, error)
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) CreateLesson(context.Context, *CreateLessonRequest) (*Lesson, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLesson not implemented")
}
func (UnimplementedEventServiceServer) GetLesson(context.Context, *GetLessonRequest) (*Lesson, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLesson not implemented")
}
func (UnimplementedEventServiceServer) ListLessons(*LessonFilter, grpc.ServerStreamingServer[Lesson]) error {
	return status.Errorf(codes.Unimplemented, "method ListLessons not implemented")
}
func (UnimplementedEventServiceServer) UpdateLesson(context.Context, *UpdateLessonRequest) (*Lesson, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLesson not implemented")
}
func (UnimplementedEventServiceServer) DeleteLesson(context.Context, *DeleteLessonRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLesson not implemented")
}
func (UnimplementedEventServiceServer) CreateTask(context.Context, *CreateTaskRequest) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTask not implemented")
}
func (UnimplementedEventServiceServer) GetTask(context.Context, *GetTaskRequest) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTask not implemented")
}
func (UnimplementedEventServiceServer) ListTasks(*TaskFilter, grpc.ServerStreamingServer[Task]) error {
	return status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}
func (UnimplementedEventServiceServer) UpdateTask(context.Context, *UpdateTaskRequest) (*Task, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTask not implemented")
}
func (UnimplementedEventServiceServer) DeleteTask(context.Context, *DeleteTaskRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTask not implemented")
}
func (UnimplementedEventServiceServer) CreateLessonSchedule(context.Context, *CreateLessonScheduleRequest) (*LessonSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLessonSchedule not implemented")
}
func (UnimplementedEventServiceServer) GetLessonSchedule(context.Context, *GetLessonScheduleRequest) (*LessonSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLessonSchedule not implemented")
}
func (UnimplementedEventServiceServer) ListLessonSchedules(*LessonScheduleFilter, grpc.ServerStreamingServer[LessonSchedule]) error {
	return status.Errorf(codes.Unimplemented, "method ListLessonSchedules not implemented")
}
func (UnimplementedEventServiceServer) UpdateLessonSchedule(context.Context, *UpdateLessonScheduleRequest) (*LessonSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLessonSchedule not implemented")
}
func (UnimplementedEventServiceServer) DeleteLessonSchedule(context.Context, *DeleteScheduleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLessonSchedule not implemented")
}
func (UnimplementedEventServiceServer) CreateTaskSchedule(context.Context, *CreateTaskScheduleRequest) (*TaskSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTaskSchedule not implemented")
}
func (UnimplementedEventServiceServer) GetTaskSchedule(context.Context, *GetTaskScheduleRequest) (*TaskSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskSchedule not implemented")
}
func (UnimplementedEventServiceServer) ListTaskSchedules(*TaskScheduleFilter, grpc.ServerStreamingServer[TaskSchedule]) error {
	return status.Errorf(codes.Unimplemented, "method ListTaskSchedules not implemented")
}
func (UnimplementedEventServiceServer) UpdateTaskSchedule(context.Context, *UpdateTaskScheduleRequest) (*TaskSchedule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTaskSchedule not implemented")
}
func (UnimplementedEventServiceServer) DeleteTaskSchedule(context.Context, *DeleteScheduleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTaskSchedule not implemented")
}
func (UnimplementedEventServiceServer) BatchCreateLessons(context.Context, *BatchCreateLessonsRequest) (*BatchLessonsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateLessons not implemented")
}
func (UnimplementedEventServiceServer) BatchCreateTasks(context.Context, *BatchCreateTasksRequest) (*BatchTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateTasks not implemented")
}
func (UnimplementedEventServiceServer) BatchUpdateLessons(context.Context, *BatchUpdateLessonsRequest) (*BatchLessonsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateLessons not implemented")
}
func (UnimplementedEventServiceServer) BatchUpdateTasks(context.Context, *BatchUpdateTasksRequest) (*BatchTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateTasks not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call pancis, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_CreateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateLesson(ctx, req.(*CreateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetLesson(ctx, req.(*GetLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListLessons_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LessonFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).ListLessons(m, &grpc.GenericServerStream[LessonFilter, Lesson]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListLessonsServer = grpc.ServerStreamingServer[Lesson]

func _EventService_UpdateLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).UpdateLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_UpdateLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).UpdateLesson(ctx, req.(*UpdateLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_DeleteLesson_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLessonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).DeleteLesson(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_DeleteLesson_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).DeleteLesson(ctx, req.(*DeleteLessonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateTask(ctx, req.(*CreateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListTasks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).ListTasks(m, &grpc.GenericServerStream[TaskFilter, Task]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListTasksServer = grpc.ServerStreamingServer[Task]

func _EventService_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_UpdateTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_DeleteTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).DeleteTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_DeleteTask_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).DeleteTask(ctx, req.(*DeleteTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_CreateLessonSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLessonScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateLessonSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateLessonSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateLessonSchedule(ctx, req.(*CreateLessonScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetLessonSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLessonScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetLessonSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetLessonSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetLessonSchedule(ctx, req.(*GetLessonScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListLessonSchedules_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LessonScheduleFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).ListLessonSchedules(m, &grpc.GenericServerStream[LessonScheduleFilter, LessonSchedule]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListLessonSchedulesServer = grpc.ServerStreamingServer[LessonSchedule]

func _EventService_UpdateLessonSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLessonScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).UpdateLessonSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_UpdateLessonSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).UpdateLessonSchedule(ctx, req.(*UpdateLessonScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_DeleteLessonSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).DeleteLessonSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_DeleteLessonSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).DeleteLessonSchedule(ctx, req.(*DeleteScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_CreateTaskSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).CreateTaskSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_CreateTaskSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).CreateTaskSchedule(ctx, req.(*CreateTaskScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_GetTaskSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).GetTaskSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_GetTaskSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).GetTaskSchedule(ctx, req.(*GetTaskScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_ListTaskSchedules_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TaskScheduleFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).ListTaskSchedules(m, &grpc.GenericServerStream[TaskScheduleFilter, TaskSchedule]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ListTaskSchedulesServer = grpc.ServerStreamingServer[TaskSchedule]

func _EventService_UpdateTaskSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).UpdateTaskSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_UpdateTaskSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).UpdateTaskSchedule(ctx, req.(*UpdateTaskScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_DeleteTaskSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).DeleteTaskSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_DeleteTaskSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).DeleteTaskSchedule(ctx, req.(*DeleteScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_BatchCreateLessons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateLessonsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).BatchCreateLessons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_BatchCreateLessons_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).BatchCreateLessons(ctx, req.(*BatchCreateLessonsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_BatchCreateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).BatchCreateTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_BatchCreateTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).BatchCreateTasks(ctx, req.(*BatchCreateTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_BatchUpdateLessons_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateLessonsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).BatchUpdateLessons(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_BatchUpdateLessons_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).BatchUpdateLessons(ctx, req.(*BatchUpdateLessonsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_BatchUpdateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).BatchUpdateTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_BatchUpdateTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).BatchUpdateTasks(ctx, req.(*BatchUpdateTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "events.v1.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLesson",
			Handler:    _EventService_CreateLesson_Handler,
		},
		{
			MethodName: "GetLesson",
			Handler:    _EventService_GetLesson_Handler,
		},
		{
			MethodName: "UpdateLesson",
			Handler:    _EventService_UpdateLesson_Handler,
		},
		{
			MethodName: "DeleteLesson",
			Handler:    _EventService_DeleteLesson_Handler,
		},
		{
			MethodName: "CreateTask",
			Handler:    _EventService_CreateTask_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _EventService_GetTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _EventService_UpdateTask_Handler,
		},
		{
			MethodName: "DeleteTask",
			Handler:    _EventService_DeleteTask_Handler,
		},
		{
			MethodName: "CreateLessonSchedule",
			Handler:    _EventService_CreateLessonSchedule_Handler,
		},
		{
			MethodName: "GetLessonSchedule",
			Handler:    _EventService_GetLessonSchedule_Handler,
		},
		{
			MethodName: "UpdateLessonSchedule",
			Handler:    _EventService_UpdateLessonSchedule_Handler,
		},
		{
			MethodName: "DeleteLessonSchedule",
			Handler:    _EventService_DeleteLessonSchedule_Handler,
		},
		{
			MethodName: "CreateTaskSchedule",
			Handler:    _EventService_CreateTaskSchedule_Handler,
		},
		{
			MethodName: "GetTaskSchedule",
			Handler:    _EventService_GetTaskSchedule_Handler,
		},
		{
			MethodName: "UpdateTaskSchedule",
			Handler:    _EventService_UpdateTaskSchedule_Handler,
		},
		{
			MethodName: "DeleteTaskSchedule",
			Handler:    _EventService_DeleteTaskSchedule_Handler,
		},
		{
			MethodName: "BatchCreateLessons",
			Handler:    _EventService_BatchCreateLessons_Handler,
		},
		{
			MethodName: "BatchCreateTasks",
			Handler:    _EventService_BatchCreateTasks_Handler,
		},
		{
			MethodName: "BatchUpdateLessons",
			Handler:    _EventService_BatchUpdateLessons_Handler,
		},
		{
			MethodName: "BatchUpdateTasks",
			Handler:    _EventService_BatchUpdateTasks_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListLessons",
			Handler:       _EventService_ListLessons_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTasks",
			Handler:       _EventService_ListTasks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListLessonSchedules",
			Handler:       _EventService_ListLessonSchedules_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTaskSchedules",
			Handler:       _EventService_ListTaskSchedules_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "events/v1/event.proto",
}
